{"version":3,"sources":["webpack:///./src/views/diaryviews/diary04.vue?7d90","webpack:///./src/views/diaryviews/diary04.vue?c014","webpack:///src/views/diaryviews/diary04.vue","webpack:///./src/views/diaryviews/diary04.vue?2603","webpack:///./src/views/diaryviews/diary04.vue"],"names":["render","_vm","this","_h","$createElement","_c","_self","staticClass","_v","directives","name","rawName","attrs","_m","staticRenderFns","component"],"mappings":"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","file":"js/chunk-f1e735f0.415a705c.js","sourcesContent":["import mod from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../../node_modules/css-loader/index.js??ref--6-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./diary04.vue?vue&type=style&index=0&lang=css&\"; export default mod; export * from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../../node_modules/css-loader/index.js??ref--6-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./diary04.vue?vue&type=style&index=0&lang=css&\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"h3-comp\"},[_c('h3',{staticClass:\"h3-title\"},[_vm._v(\"javascript中的面向对象(一)\")]),_c('p',[_vm._v(\"\\n    javascript和其他面向对象语言的不同之处在于，javascript没有类的概念，javscript中的对象也和其他语言中的对象大不相同。但这并不妨碍javascript利用面向对象的思想，实现面向对象的开发模式。\\n  \")]),_c('h4',[_vm._v(\"创建对象的方式\")]),_c('p',[_vm._v(\"\\n    在学习面向对象之前，我们先回顾一下javascript中如何创建对象。最简单直接的办法，是直接定义和赋值。\\n  \")]),_c('div',{staticClass:\"code-box\"},[_c('div',{directives:[{name:\"highlight\",rawName:\"v-highlight\"}],attrs:{\"id\":\"codeView\"}},[_vm._m(0)])]),_c('p',[_vm._v(\"\\n    从上面的代码中不难看出，这种直接定义的方式非常不便，当我们需要定义多个有着相同属性和方法的对象时，必须一个个手动创建。为了解决这个问题，我们尝试了几种新的方式，可以更方便地创建对象。\\n  \")]),_c('h4',[_vm._v(\"工厂模式\")]),_c('p',[_vm._v(\"\\n    工厂模式是用函数来封装创建对象的细节，直接调用函数进行对象创建，从而减少相似对象生成时繁琐的赋值操作。例子如下\\n  \")]),_c('div',{staticClass:\"code-box\"},[_c('div',{directives:[{name:\"highlight\",rawName:\"v-highlight\"}],attrs:{\"id\":\"codeView\"}},[_vm._m(1)])]),_c('p',[_vm._v(\"\\n    这种办法虽然可以简化相似对象的生成，但又出现了一个新的问题。当我们拿到一个已经被创建完毕的实例对象person1，我们要怎么知道它是个什么类型的对象呢？我们必须追溯到该实例对象被创建时，也就是person1=Person（\\\"k\\\",18）中，根据创建该对象的函数判断这是一个什么对象。不能及时地获取对象的类型，对模块化编程来说是极度不便的。\\n  \")]),_c('p',[_vm._v(\"于是，一种新的对象创建模式被开发了出来。\")]),_c('h4',[_vm._v(\"构造函数模式\")]),_c('p',[_vm._v(\"\\n    利用构造函数和new关键字，封装自定义的构造函数，是我们常用的创建对象方式之一。\\n  \")]),_c('div',{staticClass:\"code-box\"},[_c('div',{directives:[{name:\"highlight\",rawName:\"v-highlight\"}],attrs:{\"id\":\"codeView\"}},[_vm._m(2)])]),_c('p',[_vm._v(\"\\n    这种方式的好处在于，可以根据实例对象的constructor属性或利用instanceof操作符获取对象的类型。如\\n  \")]),_c('div',{staticClass:\"code-box\"},[_c('div',{directives:[{name:\"highlight\",rawName:\"v-highlight\"}],attrs:{\"id\":\"codeView\"}},[_vm._m(3)])]),_c('p',[_vm._v(\"\\n    构造函数解决了获取对象类型的问题，但构造函数的另一个问题在于，直接写在构造函数中的方法，在每一个实例对象被创建时都会重新创建一次。例如上面代码中，person1与perosn2都创建了showAge方法，这种办法浪费了大量的内存空间，也是不可取的。\\n  \")]),_c('h4',[_vm._v(\"构造函数与原型模式的配合\")]),_c('p',[_vm._v(\"\\n    对于原型链的内容，我们以前已经介绍过。当实例对象访问属性时，会先从自己内部寻找是否存在该属性，若存在则直接访问，不存在的话会沿着__proto\\n    __属性寻找自己的“父类”，从自己的构造函数的prototype对象寻找该属性。若能找到便访问，不能则继续沿着__proto\\n    __访问上一级的构造函数的prototype对象，直至找到该属性或访问到原型链尽头为止。\\n  \")]),_c('p',[_vm._v(\"\\n    由于这个特性的存在，我们可以将不同实例对象共用的方法属性放置在构造函数的prototype对象中，那么它的所有实例对象都可以直接访问使用，大大节省了内存空间。\\n  \")]),_c('div',{staticClass:\"code-box\"},[_c('div',{directives:[{name:\"highlight\",rawName:\"v-highlight\"}],attrs:{\"id\":\"codeView\"}},[_vm._m(4)])]),_c('p',[_vm._v(\"\\n    利用原型链和构造函数的组合，我们将共用属性和方法放到了构造函数的原型对象上，使得每个实例对象在不创建该属性的情况下得以访问这些属性，大大节省了内存空间。\\n    当然，为了书写方便，我们可以把原型赋值放入构造函数中，也就是我们的动态原型模式。\\n  \")]),_c('div',{staticClass:\"code-box\"},[_c('div',{directives:[{name:\"highlight\",rawName:\"v-highlight\"}],attrs:{\"id\":\"codeView\"}},[_vm._m(5)])]),_c('p',[_vm._v(\"\\n    这种方式在第一个实例对象被创建时，构造函数会在Person.prototype中添加必要的公共属性，书写要规范一些，但和直接定义原型方法没有太大的差异。\\n  \")]),_c('h4',[_vm._v(\"寄生构造函数模式\")]),_c('p',[_vm._v(\"\\n    寄生构造函数模式是非常罕见也非常少用的一种模式，它主要用在内置不可修改对象的拓展上。\\n  \")]),_c('p',[_vm._v(\"\\n    例如我们需要一个数组类，该类又需要一个方法，求出数组内所有元素的和。通常我们不允许也不应该去直接修改Array封装对象。这时我们可以将相应对象生成代码封装成函数，再使用new关键字创建实例。这种办法便是寄生构造函数模式。\\n  \")]),_c('div',{staticClass:\"code-box\"},[_c('div',{directives:[{name:\"highlight\",rawName:\"v-highlight\"}],attrs:{\"id\":\"codeView\"}},[_vm._m(6)])]),_c('p',[_vm._v(\"\\n    虽然arr使用了new关键字构造实例对象，但当构造函数内部有return时，return的值会覆盖掉new创建出的内存中的对象，也就是说这种方法和工厂模式基本没有太大差异。这种方法同样不能辨别出对象的类型，应该尽量避免使用它。\\n  \")]),_c('h4',[_vm._v(\"稳妥构造函数模式\")]),_c('p',[_vm._v(\"\\n    某些特殊的情况，我们希望对象中的值不允许被修改。上面的所有方式中，都可直接根据对象调用属性名对属性进行修改和访问。为了避免这一点，我们可以使用稳妥构造函数模式。\\n  \")]),_c('div',{staticClass:\"code-box\"},[_c('div',{directives:[{name:\"highlight\",rawName:\"v-highlight\"}],attrs:{\"id\":\"codeView\"}},[_vm._m(7)])]),_c('p',[_vm._v(\"\\n    使用上面的方式创建出的person1，没有任何办法可以在实例对象创建以后修改原始数据，也只能通过person1暴露出的getName方法访问原始的name属性。这种创建方式使得对象的属性无法被修改，能在某些特殊的场景下保证数据的稳定性和安全性。\\n  \")])])}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('pre',[_vm._v(\"        \"),_c('code',{staticClass:\"javascript\"},[_vm._v(\"\\n          var person1 = {\\n              name : \\\"k\\\",\\n              age : 18,\\n              showAge : function () {\\n                  console.log(this.age)\\n              }\\n          };\\n\\n          var person2 = {\\n              name : \\\"m\\\",\\n              age : 22,\\n              showAge : function () {\\n                  console.log(this.age)\\n              }\\n          };\\n        \")]),_vm._v(\"\\n      \")])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('pre',[_vm._v(\"        \"),_c('code',{staticClass:\"javascript\"},[_vm._v(\"\\n          function Person(name,age) {\\n              var o = new Object();\\n              o.name = name;\\n              o.age = age;\\n              o.showAge = function () {\\n                  console.log(this.age)\\n              }\\n              return o;\\n          }\\n\\n          var person1 = Person(\\\"k\\\",18);\\n          var person2 = Person(\\\"m\\\",17);\\n        \")]),_vm._v(\"\\n      \")])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('pre',[_vm._v(\"        \"),_c('code',{staticClass:\"javascript\"},[_vm._v(\"\\n          function Person(name,age) {\\n              this.name = name;\\n              this.age = age;\\n              this.showAge = function () {\\n                  console.log(this.age)\\n              }\\n          }\\n\\n          var person1 = new Person(\\\"t\\\",25);\\n          var person2 = new Person(\\\"v\\\",26);\\n        \")]),_vm._v(\"\\n      \")])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('pre',[_vm._v(\"        \"),_c('code',{staticClass:\"javascript\"},[_vm._v(\"\\n              console.log(person1.constructor) // => Person\\n              console.log(person1 instanceof Person) // => true\\n        \")]),_vm._v(\"\\n      \")])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('pre',[_vm._v(\"        \"),_c('code',{staticClass:\"javascript\"},[_vm._v(\"\\n          function Person (name,age) {\\n              this.name = name;\\n              this.age = age;\\n          }\\n          Person.prototype.showAge = function() {\\n              console.log(this.age);\\n          }\\n          var person1 = new Person();\\n          person1.showAge();\\n          var person2 = new Person();\\n          person2.showAge();\\n        \")]),_vm._v(\"\\n      \")])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('pre',[_vm._v(\"        \"),_c('code',{staticClass:\"javascript\"},[_vm._v(\"\\n          function Person (name,age) {\\n              this.name = name;\\n              this.age = age;\\n              if(typeof this.showAge != \\\"function\\\"){\\n                  Person.prototype.showAge = function () {\\n                      console.log(this.age)\\n                  }\\n              }\\n          }\\n        \")]),_vm._v(\"\\n      \")])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('pre',[_vm._v(\"        \"),_c('code',{staticClass:\"javascript\"},[_vm._v(\"\\n          function sumArray () {\\n              var values = new Array();\\n              values.push.apply(values,arguments);\\n              values.sum = function () {\\n                  let num = 0;\\n                  sum.forEach(item => {\\n                      num += item;\\n                  })\\n                  return num;\\n              }\\n              return values;\\n          }\\n          var arr = new sumArray(1,2,3);\\n          console.log(arr.sum())// => 6\\n        \")]),_vm._v(\"\\n      \")])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('pre',[_vm._v(\"        \"),_c('code',{staticClass:\"javascript\"},[_vm._v(\"\\n          function Person(name,age){\\n              var o = new Object();\\n              o.getName = function () {\\n                  return name;\\n              }\\n              return o\\n          }\\n\\n          var person1 = Person(\\\"f\\\",12)\\n        \")]),_vm._v(\"\\n      \")])}]\n\nexport { render, staticRenderFns }","<template>\r\n  <div class=\"h3-comp\">\r\n    <h3 class=\"h3-title\">javascript中的面向对象(一)</h3>\r\n    <p>\r\n      javascript和其他面向对象语言的不同之处在于，javascript没有类的概念，javscript中的对象也和其他语言中的对象大不相同。但这并不妨碍javascript利用面向对象的思想，实现面向对象的开发模式。\r\n    </p>\r\n    <h4>创建对象的方式</h4>\r\n    <p>\r\n      在学习面向对象之前，我们先回顾一下javascript中如何创建对象。最简单直接的办法，是直接定义和赋值。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            var person1 = {\r\n                name : \"k\",\r\n                age : 18,\r\n                showAge : function () {\r\n                    console.log(this.age)\r\n                }\r\n            };\r\n\r\n            var person2 = {\r\n                name : \"m\",\r\n                age : 22,\r\n                showAge : function () {\r\n                    console.log(this.age)\r\n                }\r\n            };\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      从上面的代码中不难看出，这种直接定义的方式非常不便，当我们需要定义多个有着相同属性和方法的对象时，必须一个个手动创建。为了解决这个问题，我们尝试了几种新的方式，可以更方便地创建对象。\r\n    </p>\r\n    <h4>工厂模式</h4>\r\n    <p>\r\n      工厂模式是用函数来封装创建对象的细节，直接调用函数进行对象创建，从而减少相似对象生成时繁琐的赋值操作。例子如下\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            function Person(name,age) {\r\n                var o = new Object();\r\n                o.name = name;\r\n                o.age = age;\r\n                o.showAge = function () {\r\n                    console.log(this.age)\r\n                }\r\n                return o;\r\n            }\r\n\r\n            var person1 = Person(\"k\",18);\r\n            var person2 = Person(\"m\",17);\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      这种办法虽然可以简化相似对象的生成，但又出现了一个新的问题。当我们拿到一个已经被创建完毕的实例对象person1，我们要怎么知道它是个什么类型的对象呢？我们必须追溯到该实例对象被创建时，也就是person1=Person（\"k\",18）中，根据创建该对象的函数判断这是一个什么对象。不能及时地获取对象的类型，对模块化编程来说是极度不便的。\r\n    </p>\r\n    <p>于是，一种新的对象创建模式被开发了出来。</p>\r\n    <h4>构造函数模式</h4>\r\n    <p>\r\n      利用构造函数和new关键字，封装自定义的构造函数，是我们常用的创建对象方式之一。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            function Person(name,age) {\r\n                this.name = name;\r\n                this.age = age;\r\n                this.showAge = function () {\r\n                    console.log(this.age)\r\n                }\r\n            }\r\n\r\n            var person1 = new Person(\"t\",25);\r\n            var person2 = new Person(\"v\",26);\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      这种方式的好处在于，可以根据实例对象的constructor属性或利用instanceof操作符获取对象的类型。如\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n                console.log(person1.constructor) // => Person\r\n                console.log(person1 instanceof Person) // => true\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      构造函数解决了获取对象类型的问题，但构造函数的另一个问题在于，直接写在构造函数中的方法，在每一个实例对象被创建时都会重新创建一次。例如上面代码中，person1与perosn2都创建了showAge方法，这种办法浪费了大量的内存空间，也是不可取的。\r\n    </p>\r\n    <h4>构造函数与原型模式的配合</h4>\r\n    <p>\r\n      对于原型链的内容，我们以前已经介绍过。当实例对象访问属性时，会先从自己内部寻找是否存在该属性，若存在则直接访问，不存在的话会沿着__proto\r\n      __属性寻找自己的“父类”，从自己的构造函数的prototype对象寻找该属性。若能找到便访问，不能则继续沿着__proto\r\n      __访问上一级的构造函数的prototype对象，直至找到该属性或访问到原型链尽头为止。\r\n    </p>\r\n    <p>\r\n      由于这个特性的存在，我们可以将不同实例对象共用的方法属性放置在构造函数的prototype对象中，那么它的所有实例对象都可以直接访问使用，大大节省了内存空间。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            function Person (name,age) {\r\n                this.name = name;\r\n                this.age = age;\r\n            }\r\n            Person.prototype.showAge = function() {\r\n                console.log(this.age);\r\n            }\r\n            var person1 = new Person();\r\n            person1.showAge();\r\n            var person2 = new Person();\r\n            person2.showAge();\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      利用原型链和构造函数的组合，我们将共用属性和方法放到了构造函数的原型对象上，使得每个实例对象在不创建该属性的情况下得以访问这些属性，大大节省了内存空间。\r\n      当然，为了书写方便，我们可以把原型赋值放入构造函数中，也就是我们的动态原型模式。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            function Person (name,age) {\r\n                this.name = name;\r\n                this.age = age;\r\n                if(typeof this.showAge != \"function\"){\r\n                    Person.prototype.showAge = function () {\r\n                        console.log(this.age)\r\n                    }\r\n                }\r\n            }\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      这种方式在第一个实例对象被创建时，构造函数会在Person.prototype中添加必要的公共属性，书写要规范一些，但和直接定义原型方法没有太大的差异。\r\n    </p>\r\n    <h4>寄生构造函数模式</h4>\r\n    <p>\r\n      寄生构造函数模式是非常罕见也非常少用的一种模式，它主要用在内置不可修改对象的拓展上。\r\n    </p>\r\n    <p>\r\n      例如我们需要一个数组类，该类又需要一个方法，求出数组内所有元素的和。通常我们不允许也不应该去直接修改Array封装对象。这时我们可以将相应对象生成代码封装成函数，再使用new关键字创建实例。这种办法便是寄生构造函数模式。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            function sumArray () {\r\n                var values = new Array();\r\n                values.push.apply(values,arguments);\r\n                values.sum = function () {\r\n                    let num = 0;\r\n                    sum.forEach(item => {\r\n                        num += item;\r\n                    })\r\n                    return num;\r\n                }\r\n                return values;\r\n            }\r\n            var arr = new sumArray(1,2,3);\r\n            console.log(arr.sum())// => 6\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      虽然arr使用了new关键字构造实例对象，但当构造函数内部有return时，return的值会覆盖掉new创建出的内存中的对象，也就是说这种方法和工厂模式基本没有太大差异。这种方法同样不能辨别出对象的类型，应该尽量避免使用它。\r\n    </p>\r\n    <h4>稳妥构造函数模式</h4>\r\n    <p>\r\n      某些特殊的情况，我们希望对象中的值不允许被修改。上面的所有方式中，都可直接根据对象调用属性名对属性进行修改和访问。为了避免这一点，我们可以使用稳妥构造函数模式。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            function Person(name,age){\r\n                var o = new Object();\r\n                o.getName = function () {\r\n                    return name;\r\n                }\r\n                return o\r\n            }\r\n\r\n            var person1 = Person(\"f\",12)\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      使用上面的方式创建出的person1，没有任何办法可以在实例对象创建以后修改原始数据，也只能通过person1暴露出的getName方法访问原始的name属性。这种创建方式使得对象的属性无法被修改，能在某些特殊的场景下保证数据的稳定性和安全性。\r\n    </p>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {};\r\n</script>\r\n\r\n<style>\r\n@import url(\"./css/diary.css\");\r\n</style>","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./diary04.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./diary04.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./diary04.vue?vue&type=template&id=39a03b44&\"\nimport script from \"./diary04.vue?vue&type=script&lang=js&\"\nexport * from \"./diary04.vue?vue&type=script&lang=js&\"\nimport style0 from \"./diary04.vue?vue&type=style&index=0&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}