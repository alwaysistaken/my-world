{"remainingRequest":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\cache-loader\\dist\\cjs.js??ref--0-0!C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\pk\\Desktop\\my-world\\web\\src\\views\\diaryviews\\diary04.vue?vue&type=template&id=5c23699d&","dependencies":[{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\src\\views\\diaryviews\\diary04.vue","mtime":1605007585067},{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":499162500000},{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { staticClass: \"h3-comp\" }, [\n    _c(\"h3\", { staticClass: \"h3-title\" }, [\n      _vm._v(\"javascript中的面向对象(一)\")\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    javascript和其他面向对象语言的不同之处在于，javascript没有类的概念，javscript中的对象也和其他语言中的对象大不相同。但这并不妨碍javascript利用面向对象的思想，实现面向对象的开发模式。\\n  \"\n      )\n    ]),\n    _c(\"h4\", [_vm._v(\"创建对象的方式\")]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    在学习面向对象之前，我们先回顾一下javascript中如何创建对象。最简单直接的办法，是直接定义和赋值。\\n  \"\n      )\n    ]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(0)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    从上面的代码中不难看出，这种直接定义的方式非常不便，当我们需要定义多个有着相同属性和方法的对象时，必须一个个手动创建。为了解决这个问题，我们尝试了几种新的方式，可以更方便地创建对象。\\n  \"\n      )\n    ]),\n    _c(\"h4\", [_vm._v(\"工厂模式\")]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    工厂模式是用函数来封装创建对象的细节，直接调用函数进行对象创建，从而减少相似对象生成时繁琐的赋值操作。例子如下\\n  \"\n      )\n    ]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(1)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        '\\n    这种办法虽然可以简化相似对象的生成，但又出现了一个新的问题。当我们拿到一个已经被创建完毕的实例对象person1，我们要怎么知道它是个什么类型的对象呢？我们必须追溯到该实例对象被创建时，也就是person1=Person（\"k\",18）中，根据创建该对象的函数判断这是一个什么对象。不能及时地获取对象的类型，对模块化编程来说是极度不便的。\\n  '\n      )\n    ]),\n    _c(\"p\", [_vm._v(\"于是，一种新的对象创建模式被开发了出来。\")]),\n    _c(\"h4\", [_vm._v(\"构造函数模式\")]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    利用构造函数和new关键字，封装自定义的构造函数，是我们常用的创建对象方式之一。\\n  \"\n      )\n    ]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(2)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    这种方式的好处在于，可以根据实例对象的constructor属性或利用instanceof操作符获取对象的类型。如\\n  \"\n      )\n    ]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(3)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    构造函数解决了获取对象类型的问题，但构造函数的另一个问题在于，直接写在构造函数中的方法，在每一个实例对象被创建时都会重新创建一次。例如上面代码中，person1与perosn2都创建了showAge方法，这种办法浪费了大量的内存空间，也是不可取的。\\n  \"\n      )\n    ]),\n    _c(\"h4\", [_vm._v(\"构造函数与原型模式的配合\")]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    对于原型链的内容，我们以前已经介绍过。当实例对象访问属性时，会先从自己内部寻找是否存在该属性，若存在则直接访问，不存在的话会沿着__proto\\n    __属性寻找自己的“父类”，从自己的构造函数的prototype对象寻找该属性。若能找到便访问，不能则继续沿着__proto\\n    __访问上一级的构造函数的prototype对象，直至找到该属性或访问到原型链尽头为止。\\n  \"\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    由于这个特性的存在，我们可以将不同实例对象共用的方法属性放置在构造函数的prototype对象中，那么它的所有实例对象都可以直接访问使用，大大节省了内存空间。\\n  \"\n      )\n    ]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(4)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    利用原型链和构造函数的组合，我们将共用属性和方法放到了构造函数的原型对象上，使得每个实例对象在不创建该属性的情况下得以访问这些属性，大大节省了内存空间。\\n    当然，为了书写方便，我们可以把原型赋值放入构造函数中，也就是我们的动态原型模式。\\n  \"\n      )\n    ]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(5)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    这种方式在第一个实例对象被创建时，构造函数会在Person.prototype中添加必要的公共属性，书写要规范一些，但和直接定义原型方法没有太大的差异。\\n  \"\n      )\n    ]),\n    _c(\"h4\", [_vm._v(\"寄生构造函数模式\")]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    寄生构造函数模式是非常罕见也非常少用的一种模式，它主要用在内置不可修改对象的拓展上。\\n  \"\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    例如我们需要一个数组类，该类又需要一个方法，求出数组内所有元素的和。通常我们不允许也不应该去直接修改Array封装对象。这时我们可以将相应对象生成代码封装成函数，再使用new关键字创建实例。这种办法便是寄生构造函数模式。\\n  \"\n      )\n    ]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(6)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    虽然arr使用了new关键字构造实例对象，但当构造函数内部有return时，return的值会覆盖掉new创建出的内存中的对象，也就是说这种方法和工厂模式基本没有太大差异。这种方法同样不能辨别出对象的类型，应该尽量避免使用它。\\n  \"\n      )\n    ]),\n    _c(\"h4\", [_vm._v(\"稳妥构造函数模式\")]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    某些特殊的情况，我们希望对象中的值不允许被修改。上面的所有方式中，都可直接根据对象调用属性名对属性进行修改和访问。为了避免这一点，我们可以使用稳妥构造函数模式。\\n  \"\n      )\n    ]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(7)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    使用上面的方式创建出的person1，没有任何办法可以在实例对象创建以后修改原始数据，也只能通过person1暴露出的getName方法访问原始的name属性。这种创建方式使得对象的属性无法被修改，能在某些特殊的场景下保证数据的稳定性和安全性。\\n  \"\n      )\n    ])\n  ])\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          '\\n          var person1 = {\\n              name : \"k\",\\n              age : 18,\\n              showAge : function () {\\n                  console.log(this.age)\\n              }\\n          };\\n\\n          var person2 = {\\n              name : \"m\",\\n              age : 22,\\n              showAge : function () {\\n                  console.log(this.age)\\n              }\\n          };\\n        '\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          '\\n          function Person(name,age) {\\n              var o = new Object();\\n              o.name = name;\\n              o.age = age;\\n              o.showAge = function () {\\n                  console.log(this.age)\\n              }\\n              return o;\\n          }\\n\\n          var person1 = Person(\"k\",18);\\n          var person2 = Person(\"m\",17);\\n        '\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          '\\n          function Person(name,age) {\\n              this.name = name;\\n              this.age = age;\\n              this.showAge = function () {\\n                  console.log(this.age)\\n              }\\n          }\\n\\n          var person1 = new Person(\"t\",25);\\n          var person2 = new Person(\"v\",26);\\n        '\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          \"\\n              console.log(person1.constructor) // => Person\\n              console.log(person1 instanceof Person) // => true\\n        \"\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          \"\\n          function Person (name,age) {\\n              this.name = name;\\n              this.age = age;\\n          }\\n          Person.prototype.showAge = function() {\\n              console.log(this.age);\\n          }\\n          var person1 = new Person();\\n          person1.showAge();\\n          var person2 = new Person();\\n          person2.showAge();\\n        \"\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          '\\n          function Person (name,age) {\\n              this.name = name;\\n              this.age = age;\\n              if(typeof this.showAge != \"function\"){\\n                  Person.prototype.showAge = function () {\\n                      console.log(this.age)\\n                  }\\n              }\\n          }\\n        '\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          \"\\n          function sumArray () {\\n              var values = new Array();\\n              values.push.apply(values,arguments);\\n              values.sum = function () {\\n                  let num = 0;\\n                  sum.forEach(item => {\\n                      num += item;\\n                  })\\n                  return num;\\n              }\\n              return values;\\n          }\\n          var arr = new sumArray(1,2,3);\\n          console.log(arr.sum())// => 6\\n        \"\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          '\\n          function Person(name,age){\\n              var o = new Object();\\n              o.getName = function () {\\n                  return name;\\n              }\\n              return o\\n          }\\n\\n          var person1 = Person(\"f\",12)\\n        '\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  }\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}