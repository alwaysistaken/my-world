{"remainingRequest":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\pk\\Desktop\\my-world\\web\\src\\views\\diaryviews\\diary04.vue?vue&type=style&index=0&lang=css&","dependencies":[{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\src\\views\\diaryviews\\diary04.vue","mtime":1605007585067},{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\css-loader\\index.js","mtime":499162500000},{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\vue-loader\\lib\\loaders\\stylePostLoader.js","mtime":499162500000},{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\postcss-loader\\src\\index.js","mtime":499162500000},{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n@import url(\"./css/diary.css\");\r\n",{"version":3,"sources":["diary04.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0NA","file":"diary04.vue","sourceRoot":"src/views/diaryviews","sourcesContent":["<template>\r\n  <div class=\"h3-comp\">\r\n    <h3 class=\"h3-title\">javascript中的面向对象(一)</h3>\r\n    <p>\r\n      javascript和其他面向对象语言的不同之处在于，javascript没有类的概念，javscript中的对象也和其他语言中的对象大不相同。但这并不妨碍javascript利用面向对象的思想，实现面向对象的开发模式。\r\n    </p>\r\n    <h4>创建对象的方式</h4>\r\n    <p>\r\n      在学习面向对象之前，我们先回顾一下javascript中如何创建对象。最简单直接的办法，是直接定义和赋值。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            var person1 = {\r\n                name : \"k\",\r\n                age : 18,\r\n                showAge : function () {\r\n                    console.log(this.age)\r\n                }\r\n            };\r\n\r\n            var person2 = {\r\n                name : \"m\",\r\n                age : 22,\r\n                showAge : function () {\r\n                    console.log(this.age)\r\n                }\r\n            };\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      从上面的代码中不难看出，这种直接定义的方式非常不便，当我们需要定义多个有着相同属性和方法的对象时，必须一个个手动创建。为了解决这个问题，我们尝试了几种新的方式，可以更方便地创建对象。\r\n    </p>\r\n    <h4>工厂模式</h4>\r\n    <p>\r\n      工厂模式是用函数来封装创建对象的细节，直接调用函数进行对象创建，从而减少相似对象生成时繁琐的赋值操作。例子如下\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            function Person(name,age) {\r\n                var o = new Object();\r\n                o.name = name;\r\n                o.age = age;\r\n                o.showAge = function () {\r\n                    console.log(this.age)\r\n                }\r\n                return o;\r\n            }\r\n\r\n            var person1 = Person(\"k\",18);\r\n            var person2 = Person(\"m\",17);\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      这种办法虽然可以简化相似对象的生成，但又出现了一个新的问题。当我们拿到一个已经被创建完毕的实例对象person1，我们要怎么知道它是个什么类型的对象呢？我们必须追溯到该实例对象被创建时，也就是person1=Person（\"k\",18）中，根据创建该对象的函数判断这是一个什么对象。不能及时地获取对象的类型，对模块化编程来说是极度不便的。\r\n    </p>\r\n    <p>于是，一种新的对象创建模式被开发了出来。</p>\r\n    <h4>构造函数模式</h4>\r\n    <p>\r\n      利用构造函数和new关键字，封装自定义的构造函数，是我们常用的创建对象方式之一。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            function Person(name,age) {\r\n                this.name = name;\r\n                this.age = age;\r\n                this.showAge = function () {\r\n                    console.log(this.age)\r\n                }\r\n            }\r\n\r\n            var person1 = new Person(\"t\",25);\r\n            var person2 = new Person(\"v\",26);\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      这种方式的好处在于，可以根据实例对象的constructor属性或利用instanceof操作符获取对象的类型。如\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n                console.log(person1.constructor) // => Person\r\n                console.log(person1 instanceof Person) // => true\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      构造函数解决了获取对象类型的问题，但构造函数的另一个问题在于，直接写在构造函数中的方法，在每一个实例对象被创建时都会重新创建一次。例如上面代码中，person1与perosn2都创建了showAge方法，这种办法浪费了大量的内存空间，也是不可取的。\r\n    </p>\r\n    <h4>构造函数与原型模式的配合</h4>\r\n    <p>\r\n      对于原型链的内容，我们以前已经介绍过。当实例对象访问属性时，会先从自己内部寻找是否存在该属性，若存在则直接访问，不存在的话会沿着__proto\r\n      __属性寻找自己的“父类”，从自己的构造函数的prototype对象寻找该属性。若能找到便访问，不能则继续沿着__proto\r\n      __访问上一级的构造函数的prototype对象，直至找到该属性或访问到原型链尽头为止。\r\n    </p>\r\n    <p>\r\n      由于这个特性的存在，我们可以将不同实例对象共用的方法属性放置在构造函数的prototype对象中，那么它的所有实例对象都可以直接访问使用，大大节省了内存空间。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            function Person (name,age) {\r\n                this.name = name;\r\n                this.age = age;\r\n            }\r\n            Person.prototype.showAge = function() {\r\n                console.log(this.age);\r\n            }\r\n            var person1 = new Person();\r\n            person1.showAge();\r\n            var person2 = new Person();\r\n            person2.showAge();\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      利用原型链和构造函数的组合，我们将共用属性和方法放到了构造函数的原型对象上，使得每个实例对象在不创建该属性的情况下得以访问这些属性，大大节省了内存空间。\r\n      当然，为了书写方便，我们可以把原型赋值放入构造函数中，也就是我们的动态原型模式。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            function Person (name,age) {\r\n                this.name = name;\r\n                this.age = age;\r\n                if(typeof this.showAge != \"function\"){\r\n                    Person.prototype.showAge = function () {\r\n                        console.log(this.age)\r\n                    }\r\n                }\r\n            }\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      这种方式在第一个实例对象被创建时，构造函数会在Person.prototype中添加必要的公共属性，书写要规范一些，但和直接定义原型方法没有太大的差异。\r\n    </p>\r\n    <h4>寄生构造函数模式</h4>\r\n    <p>\r\n      寄生构造函数模式是非常罕见也非常少用的一种模式，它主要用在内置不可修改对象的拓展上。\r\n    </p>\r\n    <p>\r\n      例如我们需要一个数组类，该类又需要一个方法，求出数组内所有元素的和。通常我们不允许也不应该去直接修改Array封装对象。这时我们可以将相应对象生成代码封装成函数，再使用new关键字创建实例。这种办法便是寄生构造函数模式。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            function sumArray () {\r\n                var values = new Array();\r\n                values.push.apply(values,arguments);\r\n                values.sum = function () {\r\n                    let num = 0;\r\n                    sum.forEach(item => {\r\n                        num += item;\r\n                    })\r\n                    return num;\r\n                }\r\n                return values;\r\n            }\r\n            var arr = new sumArray(1,2,3);\r\n            console.log(arr.sum())// => 6\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      虽然arr使用了new关键字构造实例对象，但当构造函数内部有return时，return的值会覆盖掉new创建出的内存中的对象，也就是说这种方法和工厂模式基本没有太大差异。这种方法同样不能辨别出对象的类型，应该尽量避免使用它。\r\n    </p>\r\n    <h4>稳妥构造函数模式</h4>\r\n    <p>\r\n      某些特殊的情况，我们希望对象中的值不允许被修改。上面的所有方式中，都可直接根据对象调用属性名对属性进行修改和访问。为了避免这一点，我们可以使用稳妥构造函数模式。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            function Person(name,age){\r\n                var o = new Object();\r\n                o.getName = function () {\r\n                    return name;\r\n                }\r\n                return o\r\n            }\r\n\r\n            var person1 = Person(\"f\",12)\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      使用上面的方式创建出的person1，没有任何办法可以在实例对象创建以后修改原始数据，也只能通过person1暴露出的getName方法访问原始的name属性。这种创建方式使得对象的属性无法被修改，能在某些特殊的场景下保证数据的稳定性和安全性。\r\n    </p>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {};\r\n</script>\r\n\r\n<style>\r\n@import url(\"./css/diary.css\");\r\n</style>"]}]}