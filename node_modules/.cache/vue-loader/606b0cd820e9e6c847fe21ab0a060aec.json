{"remainingRequest":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\pk\\Desktop\\my-world\\web\\src\\views\\diaryviews\\diary03.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\src\\views\\diaryviews\\diary03.vue","mtime":1604971918846},{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\r\nexport default {};\r\n",{"version":3,"sources":["diary03.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2ZA","file":"diary03.vue","sourceRoot":"src/views/diaryviews","sourcesContent":["<template>\r\n  <div class=\"h3-comp\">\r\n    <h3 class=\"h3-title\">javascript中的this指向</h3>\r\n    <p>\r\n      对js中的this指向问题有一个清晰的认知，是学习面向对象的重要基础。js中的this指向也和js语言中最重要的函数息息相关，因此弄清this指向问题可以说是学习javascript必不可少的一步\r\n    </p>\r\n    <h4>一、函数被直接调用时this指向的默认绑定规则</h4>\r\n    <p>\r\n      学习this指向时我经常看到一句话，this指向最后调用它的对象。这句话我认为有两个重点，一是this指向的，是最后才调用它的对象；二是this的指向并非在函数声明时确定的。只有函数被执行时，才能获取它的this指向。个人觉得这句话并不完全正确，首先我们来看下面的例子\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            var a = 10;\r\n            function fn () {\r\n                console.log(this.a);\r\n            }\r\n            fn() // => 10\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      以上代码中fn()的this指向了全局环境。当js代码放到浏览器环境中执行时，这个全局环境便是window。我们知道，在es5中，js声明全局变量都等同于给顶层对象添加相应的属性。因此以上例子中的fn可看作是顶层对象的一个属性。也就是说，下面的两种函数调用方式在非严格模式下，在浏览器环境中并无区别。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            window.fn === fn // => true  \r\n            window.a === a // => true\r\n            window.fn() === fn() // =>true\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      因此，在非严格模式下，浏览器环境中，函数被直接调用是可以看作函数被window对象进行调用，由于this永远最后调用它的对象,this便指向window。\r\n    </p>\r\n    <p>\r\n      个人觉得这种理解是不够准确的。首先在严格模式下，当函数在全局环境中直接调用时，this并不指向它的全局对象，而是指向undefinded。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            function fn(){\r\n                console.log(this)\r\n            }\r\n            fn() // => undefinded\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      其次，将顶层对象的属性和全局变量画上全等号，并非一个巧妙的设计。事实上，这个做法使得js语言在编译时无法识别变量未声明的错误，因为无法确定其是否属于顶层对象的一个属性。而es6中let和const已经对这点做出了修改。\r\n      也就是说\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            let a = 10;\r\n            console.log(window.a === a) // => false\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      所以对于函数的直接调用，最好还是不要认为“通过window对象进行调用，因此this指向window”。\r\n    </p>\r\n    <h4>函数作为对象属性被对象调用时的this指向绑定规则</h4>\r\n    <p>\r\n      这是最简单的一种情况了。在分析一切花里胡哨的this指向时，我们需要记住的只是两件事，一是函数在被调用时才确定this指向，被声明时this指向是未知的；二是函数的this总是指向最后调用它的对象。\r\n    </p>\r\n    <p>\r\n      我们先通过下面的例子简单地说明一下，怎么利用以上两点分析函数的this指向\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            let a = 8;\r\n            let obj = {\r\n                a : 10,\r\n                fn : fucntion () {\r\n                    console.log(this.a)\r\n                }\r\n            }\r\n            obj.a() // => 10\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      上面的代码非常简单，结果也是一目了然。this总是指向最后调用它的对象，那么我们怎么分析和找到这个对象呢，画函数上下文环境栈是个好办法，分析作用域链也可以，但最最简单的，应该是直接看函数被执行时，紧跟着函数前面的“.”号的是哪个对象其实就可以了...\r\n    </p>\r\n    <p>接下来我们看稍微复杂一点的代码 :</p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            var a = 8;\r\n            function fn () {\r\n                console.log(this.a);\r\n            }\r\n            var obj = {\r\n                a : 10,\r\n                fn : fn\r\n            } \r\n            obj.fn(); // => 10\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      以上代码就要求我们记住另一件事，函数在被执行时，才能确定它的this指向。函数在什么时候执行？在obj.fn(\r\n      )时，因此此使this指向的便是最后调用它的obj对象。\r\n      灵活运用着两个规律，已经可以判断大部分情况下函数的this指向对象了。接下来我们再把代码变得复杂一点。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            var a = 8;\r\n            function foo () {\r\n                console.log(this.a);\r\n            }\r\n            var obj = {\r\n                a : 10,\r\n                foo : foo\r\n            }\r\n            var fn = function (fn1) {\r\n                let a = 12;\r\n                fn1();\r\n            }\r\n            foo(); // => 8\r\n            obj.foo(); // => 12\r\n            fn(foo) // => 8\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      以上三种情况只要综合运用上面的规律进行分析，便不难找出各个函数的this指向。\r\n    </p>\r\n    <p>\r\n      情况一和情况二的分析过程同上面是一致的。情况三中，我们还是要抓住函数在运行时才能确定this指向。因此分析情况三的关键在于fn1(\r\n      )。尽管这里有一个形参赋值的过程，但函数被调用时，this指向可以直接根据它的调用方式，直接判断函数体（而不是指向函数体的引用指针）在哪个上下文作用域中。而fn1(\r\n      )是被直接调用的，因此this在非严格模式下，浏览器环境中指向的是window。\r\n    </p>\r\n    <p>\r\n      <strong\r\n        >MDN中这样描述this：“this是当前执行上下文（global、function 或\r\n        eval）的一个属性”。这句话应该如何理解呢？</strong\r\n      >\r\n    </p>\r\n    <p>我们回到例三</p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            var a = 8;\r\n            function foo () {\r\n                console.log(this.a);\r\n            }\r\n            var obj = {\r\n                a : 10,\r\n                foo : foo\r\n            }\r\n            var fn = function (fn1) {\r\n                let a = 12;\r\n                fn1();\r\n            }\r\n            foo(); // => 8\r\n            obj.foo(); // => 12\r\n            fn(foo) // => 8\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      对前两次调用和this打印，我们都可以看出this指向的是它们所处的执行上下文。那么为什么fn1(\r\n      )在函数作用域fn中执行了，this却指向了全局呢？因为函数是对象，属于引用类型。当执行fn（foo）时，只是把全局环境下指向foo的一个引用地址赋值给fn1，fn1执行时，根据这个地址寻找到fn函数再执行。所以此时fn执行的就是处在全局环境下的foo，foo指向的也是全局上下文。\r\n    </p>\r\n    <h4>三、改绑this指向的三个函数</h4>\r\n    <p>\r\n      js提供了三个函数可以用于改绑this的指向，分别是call、apply、bind。这三个函数的使用也非常简单，我们先从call函数开始看起。\r\n    </p>\r\n    <h4>call方法</h4>\r\n    <p><strong>语法： function.call(thisArg, arg1, arg2, ...)</strong></p>\r\n    <p>\r\n      thisArg是指定的this绑定的值，arg1、arg2等是函数的参数。\r\n      我们看一个简单的例子\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            var obj = {\r\n                a  : 1\r\n            }\r\n            var a = 2;\r\n            var func = function (){\r\n                console.log(this.a);\r\n            }\r\n            func.call(obj); // => 1\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <h4>apply方法</h4>\r\n    <p><strong>语法 ：func.apply(thisArg, [argsArray])</strong></p>\r\n    <p>\r\n      thisArg是this指向的对象，[argsArray]是参数列表，和call唯一的区别在于[argsArray]将参数集合成一个数组进行传参。例子如下\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            var obj = {\r\n                a : 1,\r\n            }\r\n            var a = 2;\r\n            var func = function (x,y) {\r\n                console.log(x + y + this.a);\r\n            } \r\n            func.apply(obj,[5,5]); // => 11\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      apply方法除了用于改绑this对象，在拓展运算符实现之前还可用于直接将数组中的数据赋参给函数。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            var count = function(a,b,c,d){\r\n                return a + b + c + d\r\n            };\r\n            var arr = [1,2,3,4];\r\n            count.apply(null,arr);\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      这样的赋值方式在某些特殊的情况下，能够省掉遍历数组的麻烦。不过es6的拓展运算符已经可以替代这一功能了。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            var count = function (a,b,c,d){\r\n                return a + b + c + d\r\n            }\r\n            var arr = [1,2,3,4]\r\n            count(...arr)\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <h4>bind方法</h4>\r\n    <p><strong>语法 ：func.apply(thisArg, [argsArray])</strong></p>\r\n    <p>\r\n      bind方法和以上两个方法的不同之处在于，bind方法不会直接改绑原函数的this指向后立即执行原函数，而是给你返回一个this指向已经被改绑的函数。\r\n      例子如下 ：\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            var a = 10;\r\n            var obj = {\r\n                a : 20\r\n            }\r\n            var fn1 = function () {\r\n                console.log(this.a)\r\n            };\r\n            var fn2 = fn1.bind(obj);\r\n            fn2() // => 20\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <h3>四、new关键字中的this指向</h3>\r\n    <p>\r\n      若是使用new关键字创建对象，new会将this指向构造函数新创建出来的实例对象。\r\n    </p>\r\n    <p>我们看一下以下的代码 ：</p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            function Person(age, name, sex) {\r\n                this.age = age;\r\n                this.sex = sex;\r\n                this.name = name;\r\n                this.foo = function() {\r\n                    console.log(this.name)\r\n                }\r\n            }\r\n            var person = new Person(18, \"k\", \"男\");\r\n            person.foo(); // => k;\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <h3>五、箭头函数的this指向</h3>\r\n    <p>\r\n      箭头函数是es6新增的一种函数声明方式，语法非常简洁，也是我们常用的一种函数声明方式。箭头函数对比函数声明式或函数表达式，最大的特点在于它的this指向的是该函数所在的上下文中this指向的对象。若箭头函数被直接定义在全局环境，那么this则直接指向全局。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            var name = \"window\";\r\n            var obj = {\r\n                name : \"obj\",\r\n                fn : () => {\r\n                    console.log(this.name);\r\n                }\r\n            }\r\n            obj.fn();// =>window\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      如果fn不是一个箭头函数，从以上文章中我们不难分析出fn的this指向的是最后调用它的obj对象。箭头函数的特性在于，指向的是它所在的上下文中的this指向。而fn是处在obj内部的，那么this指向的便是obj上一层的上下文,也就是包裹着obj的全局上下文，在浏览器环境中便指向了的window。\r\n    </p>\r\n    <p>我们再看下面的代码</p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            var objA = {\r\n                name : \"objA\",\r\n                objB : {\r\n                    name : \"objB\",\r\n                    fn : () => {\r\n                        console.log(this.name)\r\n                    }\r\n                }\r\n            }\r\n            objA.objB.fn(); // => objA\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      我们再来分析以上的代码，this指向的是objB所处的上下文，父级objA中，所以this.name打印的是objA。\r\n    </p>\r\n    <p>箭头函数的this指向是无法被call、apply、bind更改的。</p>\r\n    <h3>箭头函数在闭包中的小妙用</h3>\r\n    <p>在过去使用闭包时，this指向的遗留问题会造成一点小麻烦。例如</p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            var name = \"window\";\r\n            var obj = {\r\n                name : \"obj\",\r\n                getName : function () {\r\n                    return function(){\r\n                        console.log(this.name)\r\n                    }\r\n                }\r\n            }\r\n            var myname = obj.getName();\r\n            myname(); // =>window\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      由于myname被直接调用，从上面的分析中我们可以知道在浏览器环境下this指向的是window。而getName方法被暴露的初衷在于返回obj的name属性，this指向的改变容易导致错误。\r\n    </p>\r\n    <div class=\"code-box\">\r\n      <div id=\"codeView\" v-highlight>\r\n        <pre>\r\n          <code class=\"javascript\">\r\n            var name = \"window\";\r\n            var obj = {\r\n                name : \"obj\",\r\n                getName : function () {\r\n                    return () => {\r\n                        console.log(this.name)\r\n                    }\r\n                }\r\n            }\r\n            var myname = obj.getName();\r\n            myname(); // =>obj\r\n          </code>\r\n        </pre>\r\n      </div>\r\n    </div>\r\n    <p>\r\n      我们将getName内部返回的函数变成箭头函数，此时箭头函数的this永远指向了getName的上级对象obj。\r\n    </p>\r\n  </div>\r\n</template>\r\n\r\n<style>\r\n@import url(\"./css/diary.css\");\r\n</style>\r\n\r\n<script>\r\nexport default {};\r\n</script>"]}]}