{"remainingRequest":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\cache-loader\\dist\\cjs.js??ref--0-0!C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\pk\\Desktop\\my-world\\web\\src\\views\\diaryviews\\diary02.vue?vue&type=template&id=5c073a9b&","dependencies":[{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\src\\views\\diaryviews\\diary02.vue","mtime":1604969450136},{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":499162500000},{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\pk\\Desktop\\my-world\\web\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { staticClass: \"h3-comp\" }, [\n    _c(\"h3\", { staticClass: \"h3-title\" }, [_vm._v(\"一窥javascript原型链\")]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    原型链是javascript实现面向对象的基础，所有的继承和构造都基于原型链完成。原型链这东西，说难不难，说简单也不简单。它真正让人迷惑的难点在于Function与Object二者的关系非常的复杂有趣。\\n  \"\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    那么在接触这二者之前，我们先从最简单的prototyep、__proto\\n    __属性开始学习。\\n  \"\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\"首先我们写一个构造函数，用这个构造函数创建一个实例对象。\")\n    ]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(0)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    以上代码中，我们可以认为Dog函数是一个构造函数，dog1是使用这个构造函数创建出来的一个实例对象。那么dog1和Dog之间有什么关系呢？\\n  \"\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    从这里我们可以引出两个原型链的重要属性prototype与__proto\\n    __。每个被构建出来的实例对象都有一个__proto\\n    __属性，每个构造函数都有一个prototype属性。实例对象的__proto\\n    __指向的是它的构造函数的prototype对象。上面的例子中，dog1是Dog的实例对象，因此有\\n  \"\n      )\n    ]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(1)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    那么js是如何实现继承的呢？当实例对象访问属性时，会先从自己内部寻找是否存在该属性，若存在则直接访问，不存在的话会沿着__proto\\n    __属性寻找自己的“父类”，从自己的构造函数的prototype对象寻找该属性。若能找到便访问，不能则继续沿着__proto\\n    __访问上一级的构造函数的prototype对象，直至找到该属性或访问到原型链尽头为止。\\n  \"\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    也就是说，上面的例子中dog对象是可以访问到Dog.prototype中的属性或方法的。\\n  \"\n      )\n    ]),\n    _c(\"p\", [_vm._v(\"这点我们稍微验证一下即可。\")]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(2)]\n      )\n    ]),\n    _c(\"p\", [_vm._v(\"通过__proto__原型，js实现了父类与子类之间的继承。\")]),\n    _c(\"h4\", [_vm._v(\"万物皆对象\")]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    在javascript语言中，万物皆对象，函数自然也是对象。那么函数作为一个对象，自然也有__proto\\n    __属性。我们可能不记得的是，javascript中函数有一种非常不便也几乎无人使用的函数声明方式，那就是使用Function构造函数和new关键字。\\n  \"\n      )\n    ]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(3)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    所以，Dog构造函数也是Function构造函数的一个实例对象。事实上javascript中的所有函数都可看作构造函数Function的实例对象，或许除了Function本身。\\n  \"\n      )\n    ]),\n    _c(\"p\", [_vm._v(\"所以非常自然地，我们可以得到\")]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(4)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    函数对象的构造函数是Function，那么普通对象的构造函数是什么呢？这里我们只要回忆一下，普通对象如何使用new关键字构造出来就明白了。\\n  \"\n      )\n    ]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(5)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\"由上可知，Object是普通对象的构造函数。obj1是Object的一个实例。\")\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    我们刚刚提到，在javascript里万物皆对象。但对象其实只是javascript数据类型的一种，为了给其他基本类型提供常用的操作方法，javascript提供了三个基本类型的包装对象，分别是String、Boolean和Number。\\n  \"\n      )\n    ]),\n    _c(\"p\", [_vm._v(\"我们知道，基本类型可以直接调用封装类型的方法。如\")]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(6)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    以上代码没有报错，并不是说明str是一个对象，substring是它的方法，而是因为javascript提供了String包装类型，在str调用substring方法前，js内部会自动创建一个String类型的实例，在实例中调用这个方法，然后将这个实例销毁。\\n    我们可以把以上代码看作\\n  \"\n      )\n    ]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(7)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\"那么，我们很自然地看得到，s的构造函数是String，也就是说\")\n    ]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(8)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    那么String的构造函数是谁呢?如上所说，构造函数的__proto__都指向Function，都是Function的一个实例对象。\\n  \"\n      )\n    ]),\n    _c(\"p\", [_vm._v(\"因此有\")]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(9)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    至此我们完成了原型链中大部分内容的学习，而剩下的一部分，也是最暧昧最难理解的关于Object和Function的关系了。\\n  \"\n      )\n    ]),\n    _c(\"h4\", [_vm._v(\"Object与Function的关系\")]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    研究二者之前，我们很自然地去问的一个问题是，这俩有构造函数吗？这俩有上一级的父辈吗？然后我们自然就会沿着__proto\\n    __往上查找。\\n  \"\n      )\n    ]),\n    _c(\"p\", [_vm._v(\"然后我们就会发现一个很迷惑的东西 ：\")]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(10)]\n      )\n    ]),\n    _c(\"p\", [_vm._v(\"没错，Function的__proto__指向了自己的prototype。\")]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    对于这个，通常有两种解释，一是Function是它本身的一个实例，因此它的__proto\\n    __自然地指向了自己的prototype。二是因为所有函数都可沿着__proto\\n    __找到Function.prototype，所以为了不引起误会，让本身作为函数的Function的__proto\\n    __属性也指向了自己的prototype。在能进一步深入地理解js之前，我们不妨把二者都先记住。\\n    为什么Object的__proto\\n    __也指向了Function.prototype呢？这说明Object是由Function创建出来的。那么Function.prototype怎么来的?当我们继续往上搜寻，就会发现\\n  \"\n      )\n    ]),\n    _c(\"div\", { staticClass: \"code-box\" }, [\n      _c(\n        \"div\",\n        {\n          directives: [{ name: \"highlight\", rawName: \"v-highlight\" }],\n          attrs: { id: \"codeView\" }\n        },\n        [_vm._m(11)]\n      )\n    ]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    Function.prototype的__proto __\\n    指向了Object.prototype，而Object.prototype便是原型链的终点，在往前搜寻只有一个null。\\n  \"\n      )\n    ]),\n    _c(\"p\", [_vm._v(\"对于这一套关系，个人的理解是这样的：\")]),\n    _c(\"p\", [\n      _vm._v(\n        \"\\n    js引擎先做出了一个Object.porototype，这是整个ecmascript的万物起源，Object.prototype又做出一个Function.prototype。接着Function.prototype把自己和父亲整理一下，生成了Object和Function，这二者继续往下，才有了各式各样的对象和方法，生成了一条完整的原型链。\\n  \"\n      )\n    ])\n  ])\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          \"\\n          function Dog (age) {\\n              this.age = age;\\n          }\\n          var dog1 = new Dog(10);\\n        \"\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          \"\\n          function Dog (age) {\\n              this.age = age;\\n          }\\n          var dog1 = new Dog(10);\\n          console.log(dog1.__proto__ === Dog.prototype); // => true\\n        \"\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          \"\\n          function Dog (age) {\\n              this.age = age;\\n          }\\n          var dog1 = new Dog(10);\\n          Dog.prototype.showage = function () {\\n              console.log(this.age);\\n          }\\n          dog1.showage(); // => 10\\n        \"\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\"\\n          var Dog = new Function();\\n        \")\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          \"\\n          function Dog (age) {\\n              this.age = age;\\n          }\\n          console.log(Dog.__proto__ === Function.prototype); // => true\\n        \"\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          \"\\n          var obj1 = new Object();\\n          console.log(obj1.__proto__ === Object.prorotype); // => true\\n        \"\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          '\\n          var str = \"some text\";\\n          console.log(str.substring(2));\\n        '\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          '\\n          var str = \"some text\",\\n          var s = new String(str);\\n          console.log(s.substring(2));\\n          s = null;\\n        '\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          '\\n          var s = new String(\"sffa\");\\n          console.log(s.__proto__ === String.prototype); // => true\\n        '\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          \"\\n          console.log(String.__proto__ === Funciton.prototype); // => true\\n        \"\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          \"\\n          console.log(Function.__proto__ === Function.prototype); //=>true\\n          console.log(Object.__proto__ === Function.prototype); //=>true\\n        \"\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"pre\", [\n      _vm._v(\"        \"),\n      _c(\"code\", { staticClass: \"javascript\" }, [\n        _vm._v(\n          \"\\n          console.log(Function.prototype.__proto__ === Object.__proto__); // => true\\n          console.log(Object.prototype.__proto__ === null) // => true\\n        \"\n        )\n      ]),\n      _vm._v(\"\\n      \")\n    ])\n  }\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}